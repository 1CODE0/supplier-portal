**Week 2: Database Modeling & Full CRUD**

**1. Schema Plan**
Define two primary entities: `Supplier` and `Order`, including their fields and relationship.

---

### A. Entity: Supplier

| Field          | Type     | Constraints      | Notes                      |
| -------------- | -------- | ---------------- | -------------------------- |
| `id`           | `UUID`   | PK, generated    | Use `@GeneratedValue`      |
| `name`         | `String` | not null, unique | Supplier name              |
| `contactEmail` | `String` | not null         | Must be valid email format |
| `phone`        | `String` |                  | Optional                   |
| `address`      | `String` |                  | Optional                   |

### B. Entity: Order

| Field         | Type            | Constraints           | Notes                                       |
| ------------- | --------------- | --------------------- | ------------------------------------------- |
| `id`          | `UUID`          | PK, generated         |                                             |
| `orderDate`   | `LocalDateTime` | not null              | Set default to `now()`                      |
| `status`      | `OrderStatus`   | not null              | Enum: DRAFT, SUBMITTED, COMPLETED, CANCELED |
| `totalAmount` | `BigDecimal`    | not null              | Scale 2                                     |
| `supplier`    | `Supplier`      | Many-to-One, not null | FK to `Supplier.id`                         |
| `description` | `String`        |                       | Optional                                    |

### C. Relationship

* One `Supplier` → Many `Order`
* Bi-directional or uni-directional? Use uni-directional from `Order`.

**2. JPA Entities**

```java
// Supplier.java
@Entity
@Table(name = "suppliers")
public class Supplier {
    @Id
    @GeneratedValue
    private UUID id;

    @Column(nullable = false, unique = true)
    private String name;

    @Column(nullable = false)
    private String contactEmail;

    private String phone;

    private String address;

    // getters & setters
}

// Order.java
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue
    private UUID id;

    @Column(nullable = false)
    private LocalDateTime orderDate = LocalDateTime.now();

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OrderStatus status;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal totalAmount;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;

    private String description;

    // getters & setters
}

public enum OrderStatus { DRAFT, SUBMITTED, COMPLETED, CANCELED }
```

**3. Repository & Service Layer**

* **Repositories** extend `JpaRepository` for basic CRUD and paging/sorting.
* **Services** encapsulate business logic, transactional boundaries.

```java
// SupplierRepository.java
public interface SupplierRepository extends JpaRepository<Supplier, UUID> {}

// OrderRepository.java
public interface OrderRepository extends JpaRepository<Order, UUID> {
    List<Order> findBySupplierId(UUID supplierId);
}
```

```java
// SupplierService.java
@Service
public class SupplierService {
    private final SupplierRepository repo;

    public SupplierService(SupplierRepository repo) {
        this.repo = repo;
    }

    public List<Supplier> getAll() { return repo.findAll(); }
    public Supplier getById(UUID id) { return repo.findById(id).orElseThrow(); }
    public Supplier create(Supplier s) { return repo.save(s); }
    public Supplier update(UUID id, Supplier s) {
        Supplier existing = getById(id);
        existing.setName(s.getName());
        existing.setContactEmail(s.getContactEmail());
        existing.setPhone(s.getPhone());
        existing.setAddress(s.getAddress());
        return repo.save(existing);
    }
    public void delete(UUID id) { repo.deleteById(id); }
}

// OrderService.java
@Service
public class OrderService {
    private final OrderRepository repo;
    private final SupplierService supplierService;

    public OrderService(OrderRepository repo, SupplierService supplierService) {
        this.repo = repo;
        this.supplierService = supplierService;
    }

    public List<Order> getAll() { return repo.findAll(); }
    public Order getById(UUID id) { return repo.findById(id).orElseThrow(); }
    public List<Order> getBySupplier(UUID supplierId) { return repo.findBySupplierId(supplierId); }
    public Order create(Order o) {
        // verify supplier exists
        supplierService.getById(o.getSupplier().getId());
        return repo.save(o);
    }
    public Order update(UUID id, Order o) {
        Order existing = getById(id);
        existing.setStatus(o.getStatus());
        existing.setTotalAmount(o.getTotalAmount());
        existing.setDescription(o.getDescription());
        existing.setSupplier(supplierService.getById(o.getSupplier().getId()));
        return repo.save(existing);
    }
    public void delete(UUID id) { repo.deleteById(id); }
}
```

**4. Controllers**

* Use standard REST conventions, JSON payloads.
* URL patterns: `/api/suppliers`, `/api/orders`, plus `/api/suppliers/{id}/orders`.

```java
// SupplierController.java
@RestController
@RequestMapping("/api/suppliers")
public class SupplierController {
    private final SupplierService svc;
    public SupplierController(SupplierService svc) { this.svc = svc; }

    @GetMapping
    public List<Supplier> list() { return svc.getAll(); }

    @GetMapping("/{id}")
    public Supplier get(@PathVariable UUID id) { return svc.getById(id); }

    @PostMapping
    public Supplier create(@RequestBody @Valid Supplier s) { return svc.create(s); }

    @PutMapping("/{id}")
    public Supplier update(@PathVariable UUID id, @RequestBody @Valid Supplier s) {
        return svc.update(id, s);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable UUID id) { svc.delete(id); }
}

// OrderController.java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    private final OrderService svc;
    public OrderController(OrderService svc) { this.svc = svc; }

    @GetMapping
    public List<Order> list() { return svc.getAll(); }

    @GetMapping("/supplier/{supplierId}")
    public List<Order> listBySupplier(@PathVariable UUID supplierId) {
        return svc.getBySupplier(supplierId);
    }

    @GetMapping("/{id}")
    public Order get(@PathVariable UUID id) { return svc.getById(id); }

    @PostMapping
    public Order create(@RequestBody @Valid Order o) { return svc.create(o); }

    @PutMapping("/{id}")
    public Order update(@PathVariable UUID id, @RequestBody @Valid Order o) {
        return svc.update(id, o);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable UUID id) { svc.delete(id); }
}
```

**5. Frontend: React + TanStack Query**

#### A. Directory Structure

```
src/
  └── api/
      ├── suppliers.ts
      └── orders.ts
  └── components/
      ├── SupplierForm.tsx
      ├── SupplierList.tsx
      ├── OrderForm.tsx
      └── OrderList.tsx
  └── pages/
      ├── suppliers/
      │    ├── index.tsx   // list & link to create
      │    ├── new.tsx     // create form
      │    └── [id].tsx    // edit form
      └── orders/
           ├── index.tsx
           ├── new.tsx
           └── [id].tsx
```

#### B. API Modules (`api/suppliers.ts`)

```ts
import axios from 'axios';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

const base = '/api/suppliers';

export const useSuppliers = () => useQuery(['suppliers'], () => axios.get(base).then(res => res.data));
export const useSupplier = (id: string) => useQuery(['suppliers', id], () => axios.get(`${base}/${id}`).then(res => res.data));

export const useCreateSupplier = () => {
  const qc = useQueryClient();
  return useMutation((data: any) => axios.post(base, data).then(r => r.data), {
    onSuccess: () => qc.invalidateQueries(['suppliers']),
  });
};

export const useUpdateSupplier = () => {
  const qc = useQueryClient();
  return useMutation(({ id, ...data }: any) => axios.put(`${base}/${id}`, data).then(r => r.data), {
    onSuccess: (_, vars) => qc.invalidateQueries(['suppliers', vars.id]),
  });
};

export const useDeleteSupplier = () => {
  const qc = useQueryClient();
  return useMutation((id: string) => axios.delete(`${base}/${id}`), {
    onSuccess: () => qc.invalidateQueries(['suppliers']),
  });
};
```

#### C. Components & Pages

* **List**: fetch with `useSuppliers()`, display in MUI `DataGrid` or `Table`, link to edit and delete buttons.
* **Form**: use `react-hook-form` + MUI inputs, load initial data if editing, submit via `useCreate`/`useUpdate`.
* **Navigation**: React Router or Next.js routing (React-only: react-router-dom).

> *Detailed code for each component can be scaffolded similarly to Week 1 forms.*

**Next Steps for Week 2**

1. Review and finalize entity fields.
2. Implement JPA entities, repositories, service tests.
3. Scaffold controllers; manually test via Swagger UI.
4. Build and verify API modules in frontend.
5. Scaffold list & form components; wire up React Router.
6. End-to-end smoke testing: create/update/delete flows for Suppliers & Orders.

Let's dive into implementing the JPA layer and then shift to React scaffolding!



***************************************************************************************


## **Order Entity Schema**

| **Column Name**  | **Data Type**        | **Description**                                                | **Constraints**                             |
| ---------------- | -------------------- | -------------------------------------------------------------- | ------------------------------------------- |
| **id**           | `UUID`               | Unique identifier for each order.                              | Primary Key, Auto-generated                 |
| **orderDate**    | `LocalDateTime`      | The date and time when the order was created.                  | Not Null, Default value is the current date |
| **status**       | `OrderStatus` (Enum) | The status of the order (e.g., PENDING, COMPLETED, CANCELLED). | Not Null, Enum value stored as String       |
| **totalAmount**  | `BigDecimal`         | The total amount of the order.                                 | Not Null, Precision: 10, Scale: 2           |
| **supplier\_id** | `UUID`               | Foreign key to the supplier who fulfilled the order.           | Not Null, Foreign Key (`supplier.id`)       |
| **description**  | `String`             | A description of the order (optional).                         | Nullable                                    |

### **Relationships**

* **Supplier** (`ManyToOne`): Each order is associated with one supplier. This is represented by the foreign key `supplier_id` pointing to the `id` of the `Supplier` entity.

---

## **Supplier Entity Schema**

| **Column Name**  | **Data Type** | **Description**                              | **Constraints**             |
| ---------------- | ------------- | -------------------------------------------- | --------------------------- |
| **id**           | `UUID`        | Unique identifier for each supplier.         | Primary Key, Auto-generated |
| **name**         | `String`      | The name of the supplier.                    | Not Null, Unique            |
| **contactEmail** | `String`      | The contact email of the supplier.           | Not Null                    |
| **phone**        | `String`      | The phone number of the supplier (optional). | Nullable                    |
| **address**      | `String`      | The address of the supplier (optional).      | Nullable                    |

### **Auditing Fields**

These fields are inherited from the `Auditable` class (if applicable):

* `createdAt`: Timestamp when the supplier was created.
* `updatedAt`: Timestamp when the supplier was last updated.
* These fields are managed automatically by JPA (e.g., `@PrePersist` and `@PreUpdate` annotations).

---

## **Entity Relationship Diagram (ERD)**

### **Entities:**

* **Order** has a **Many-to-One** relationship with **Supplier**.

  * Each `Order` is associated with a single `Supplier`.
  * The foreign key `supplier_id` in `Order` refers to the primary key `id` of the `Supplier`.

### **Visual Overview:**

1. **Order Entity**

   * `id (PK)`
   * `orderDate`
   * `status`
   * `totalAmount`
   * `supplier_id (FK)` → **Supplier**
   * `description`

2. **Supplier Entity**

   * `id (PK)`
   * `name`
   * `contactEmail`
   * `phone`
   * `address`

---

3. Making It Reusable: Abstract Base Class
Rather than repeating fields in every entity, define:

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable {
    @CreatedDate 
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
}

Then your entities simply extend it:

@Entity
@Table(name = "orders")
public class Order extends Auditable {
    @Id @GeneratedValue
    private UUID id;
    // … other fields …
}