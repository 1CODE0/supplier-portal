

## **Order Entity Schema**

| **Column Name**  | **Data Type**        | **Description**                                                | **Constraints**                             |
| ---------------- | -------------------- | -------------------------------------------------------------- | ------------------------------------------- |
| **id**           | `UUID`               | Unique identifier for each order.                              | Primary Key, Auto-generated                 |
| **orderDate**    | `LocalDateTime`      | The date and time when the order was created.                  | Not Null, Default value is the current date |
| **status**       | `OrderStatus` (Enum) | The status of the order (e.g., PENDING, COMPLETED, CANCELLED). | Not Null, Enum value stored as String       |
| **totalAmount**  | `BigDecimal`         | The total amount of the order.                                 | Not Null, Precision: 10, Scale: 2           |
| **supplier\_id** | `UUID`               | Foreign key to the supplier who fulfilled the order.           | Not Null, Foreign Key (`supplier.id`)       |
| **description**  | `String`             | A description of the order (optional).                         | Nullable                                    |

### **Relationships**

* **Supplier** (`ManyToOne`): Each order is associated with one supplier. This is represented by the foreign key `supplier_id` pointing to the `id` of the `Supplier` entity.

---

## **Supplier Entity Schema**

| **Column Name**  | **Data Type** | **Description**                              | **Constraints**             |
| ---------------- | ------------- | -------------------------------------------- | --------------------------- |
| **id**           | `UUID`        | Unique identifier for each supplier.         | Primary Key, Auto-generated |
| **name**         | `String`      | The name of the supplier.                    | Not Null, Unique            |
| **contactEmail** | `String`      | The contact email of the supplier.           | Not Null                    |
| **phone**        | `String`      | The phone number of the supplier (optional). | Nullable                    |
| **address**      | `String`      | The address of the supplier (optional).      | Nullable                    |

### **Auditing Fields**

These fields are inherited from the `Auditable` class (if applicable):

* `createdAt`: Timestamp when the supplier was created.
* `updatedAt`: Timestamp when the supplier was last updated.
* These fields are managed automatically by JPA (e.g., `@PrePersist` and `@PreUpdate` annotations).

---

## **Entity Relationship Diagram (ERD)**

### **Entities:**

* **Order** has a **Many-to-One** relationship with **Supplier**.

  * Each `Order` is associated with a single `Supplier`.
  * The foreign key `supplier_id` in `Order` refers to the primary key `id` of the `Supplier`.

### **Visual Overview:**

1. **Order Entity**

   * `id (PK)`
   * `orderDate`
   * `status`
   * `totalAmount`
   * `supplier_id (FK)` → **Supplier**
   * `description`

2. **Supplier Entity**

   * `id (PK)`
   * `name`
   * `contactEmail`
   * `phone`
   * `address`

---

3. Making It Reusable: Abstract Base Class
Rather than repeating fields in every entity, define:

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable {
    @CreatedDate 
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
}

Then your entities simply extend it:

@Entity
@Table(name = "orders")
public class Order extends Auditable {
    @Id @GeneratedValue
    private UUID id;
    // … other fields …
}

Few new changes added :

1. Single-flight + Controlled Retries (20 sec window)
Problem: You want “keep retrying for up to 20 s” on network hiccups, but never fire more than one request at once.

Solution:
Leverage React-Query’s built-in retry logic, which is already serial (it won’t start a new retry before the prior one errors). Configure:

useQuery<Order[], Error>({
  queryKey: ["orders"],
  queryFn: () => OrderControllerService.list(),
  retry: 5,                       // total attempts = 1 initial + 5 retries
  retryDelay: () => 4_000,        // 4 s between attempts → ~20 s total
  refetchOnWindowFocus: false,
  refetchOnReconnect: false,
});
Serial retries ensure only one in-flight call at a time.

Fixed delays give you that 20 s window to recover from transient failures.

You don’t need extra flags for “one request”—React-Query handles that for you.


2. In Entity added an annotation ---> @JsonIgnoreProperties({ "hibernateLazyInitializer", "handler" })